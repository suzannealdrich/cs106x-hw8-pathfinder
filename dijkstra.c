/* * Function: FindShortestPath * Usage: bestPath = FindShortestPath(startNode, finishNode, DistanceWeightFn); * -------------------------------------------------------- * This function uses Dijkstra's Algorithm to find the optimal path between two nodes, * where "optimal" means lowest total according to the supplied arc weighting function. * * The following changes have been made from the the algorithm in the text: * (1) The function now takes an arcWeightFn as an argument.  This is  passed * to NewPath to indicate how to weight paths (distance, time, etc.). * (2) The "foreach" notation of the text has been expanded to the explicit * use of an iterator. * (3) The function CleanUp, exported by pqueue.h, is called before the function returns. */pathADT FindShortestPath(nodeADT start, nodeADT finish, arcWeightFnT weightFn) {     pqueueADT queue;     pathADT path, newPath;     arcADT arc;	 iteratorADT iterator;     queue = NewPriorityQueue();     path = NewPath(weightFn);     while (start != finish)      {         if (!IsDistanceFixed(start))          {             FixNodeDistance(start, TotalPathDistance(path));             iterator = NewIterator(ArcsFrom(start));             while (StepIterator(iterator, &arc))             {                 if (!IsDistanceFixed(EndOfArc(arc)))                  {                     newPath = NewExtendedPath(path, arc);                     PriorityEnqueue(queue, newPath,                                     TotalPathDistance(newPath));                 }             }         }         if (IsEmpty(queue)) return (NULL);         path = PriorityDequeue(queue);         start = EndOfPath(path);     }     CleanUp(queue);     return (path); }