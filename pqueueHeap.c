/* * File:   queueHeap.c * Author: Suzanne Aldrich * ----------------- * This file implements the priority queue abstraction as a heap. */ #include "pqueue.h"#define INIT_SIZE 1024  // initial size of heap// converts 0-based array index to 1-based, // calculates parent/child, converts back to 0-based index#define parent(n) (((n) + 1) / 2 - 1)#define child0(n) (((n) + 1) * 2 + 0 - 1)#define child1(n) (((n) + 1) * 2 + 1 - 1)  struct pqueueCDT{	int *heap;	int elements;	int size;};void ExpandQueue(pqueueADT queue);void TrickleUp(pqueueADT queue, int index);void TrickleDown(pqueueADT queue, int index);/* Public functions */pqueueADT NewPriorityQueue(void){    pqueueADT queue = New(pqueueADT);    queue->heap = GetBlock(INIT_SIZE * sizeof(int));    queue->elements = 0;    queue->size = INIT_SIZE;    return queue;}void FreeQueue(pqueueADT queue){	FreeBlock(queue->heap);    FreeBlock(queue);	}bool IsEmpty(pqueueADT queue){    return (queue->elements == 0);  }bool IsFull(pqueueADT queue){    return FALSE;  }void Insert(pqueueADT queue, int newValue){ 	if (queue->elements == queue->size) ExpandQueue(queue); 	queue->heap[queue->elements++] = newValue; 	TrickleUp(queue, queue->elements - 1); }int ExtractMax(pqueueADT queue){	if (queue->elements == 0) {		Error("Tried to extract max from an empty queue!");		return NOT_FOUND;	}	return Delete(queue, queue->heap[0]);}		int Search(pqueueADT queue, int key){	int i;		for (i = 0; i < queue->elements; i++) {		if (queue->heap[i] == key) return key;	}	return NOT_FOUND;}int Delete(pqueueADT queue, int elem){		int i;		for (i = 0; i < queue->elements; i++) {		if (queue->heap[i] == elem)  {			queue->heap[i] = queue->heap[--queue->elements];  			if (i < queue->elements) TrickleDown(queue, i);			return elem;		}	}	return NOT_FOUND;}/* Private Functions */void ExpandQueue(pqueueADT queue){	int i, newsize = queue->size * 3 / 2;	int *newarray = GetBlock(newsize * sizeof(int));	for (i = 0; i < queue->size; i++) {		newarray[i] = queue->heap[i];	}	FreeBlock(queue->heap);	queue->heap = newarray;	queue->size = newsize;}void TrickleUp(pqueueADT queue, int index){	int up = parent(index);	int value = queue->heap[index];		if (index > 0 && value > queue->heap[up]) {		queue->heap[index] = queue->heap[up];		queue->heap[up] = value;		TrickleUp(queue, up);	}}void TrickleDown(pqueueADT queue, int index){	int down, a = child0(index), b = child1(index);	int value = queue->heap[index];		if ((a < queue->elements || b < queue->elements)	 && (value < queue->heap[a] || value < queue->heap[b])) {		down = (queue->heap[a] >= queue->heap[b])  ?  a : b;		queue->heap[index] = queue->heap[down];		queue->heap[down] = value;		TrickleDown(queue, down);	}}