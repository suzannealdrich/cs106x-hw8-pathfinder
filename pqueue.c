/* * File: queueArray.c * ---------------------------- * This file implements the priority queue abstraction as a fixed-sized * array of integers stored in no particular order.    */#include "pqueue.h"#define MAX_ELEMENTS 10000	// fixed size of array/* * Type: pqueueCDT * -------------------- * This type defines the underlying concrete representation for a * priority queue ADT.  These details are not relevant to and therefore * not exported to the client.  In this implementation, the * underlying structure is a fixed-sized array of integers. */struct pqueueCDT{	pqElementT entries[MAX_ELEMENTS];	int numEntries;				// effective size of the above array};static int IndexOfMin(pqElementT array[], int size);static void *DeleteElementAtIndex(pqueueADT queue, int index);/* Public functions */pqueueADT NewPriorityQueue(void){    pqueueADT queue;    queue = New(pqueueADT);    queue->numEntries = 0;    return queue;}void FreeQueue(pqueueADT queue){    FreeBlock(queue);	// not worrying about embedded pointers yet}bool IsEmpty(pqueueADT queue){    return (queue->numEntries == 0);  }bool IsFull(pqueueADT queue){    return (queue->numEntries == MAX_ELEMENTS);  }/* Function: Insert * ---------------- * Since we're keeping the array in no particular order, we just append this * new element to the end of the array.  It's the easiest and fastest thing * to do, so why not? */void PriorityEnqueue(pqueueADT queue, void *newInfo, double newValue){	if (queue->numEntries == MAX_ELEMENTS)	// no more space to add elements!		Error("Tried to insert into a priority queue which is full!");	queue->entries[queue->numEntries].info = newInfo;	queue->entries[queue->numEntries++].value = newValue;}/* Function: ExtractMax * -------------------- * Since we're keeping the array in no particular order, we have to search to * find the largest element.  We then use our helper function to extract that * element from the queue, close up the gap, and return its value. */void *PriorityDequeue(pqueueADT queue){	if (queue->numEntries == 0)		Error("Tried to extract max from an empty queue!");			return DeleteElementAtIndex(queue, IndexOfMin(queue->entries, queue->numEntries));}		/* Private Functions *//* * Function: IndexOfMin * -------------------- * Searches the array to find the index of the smallest element using * a simple linear scan. */static int IndexOfMin(pqElementT array[], int size){	int i, minIndex;		minIndex = 0;	// assume first element is smallest until proven otherwise	for (i = 1; i < size; i++)		if (array[i].value < array[minIndex].value)			minIndex = i;	return minIndex;}/* * Function: DeleteElementAtIndex * ------------------------------- * To remove a value from the middle, we move the last elem in the array * into the slot vacated by the deleted elem and decrement our number of entries. * There's no reason to shuffle the array elements down to cover the gap * since that would be expensive and pointless.  The value removed is * the one returned. */static void *DeleteElementAtIndex(pqueueADT queue, int index){	void *info;		info = queue->entries[index].info; 	// save value to return	queue->entries[index] = queue->entries[--queue->numEntries]; // swap last into this slot	return info;}