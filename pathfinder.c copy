/*  * File:   pathfinder.c * Author: Suzanne Aldrich * Date:   12/5/97 * ------------ * Pathfinder. */#include "pathfinder.h"main() {	graphADT map = InitMap();	InitGraphics();	SetWindowTitle("Pathfinder");	Welcome();	ReadFileData(map);	do { 	ClearMap(map);	GetUserNodes(map);	FindRoutes(map);	} while (BoolQuestion("Continue? (Y/N) "));	FreeGraph(map);	ExitGraphics();}graphADT InitMap(void){	graphADT map = NewGraph();	graphDataT *mapdata = GetBlock(sizeof(graphDataT));	mapdata->picture = NULL;	mapdata->nodetable = NewSymbolTable();	mapdata->start = mapdata->finish = NULL;	SetGraphData(map, (void *) mapdata);	return map;}static void Welcome(void){	printf("Welcome to Pathfinder.\n");	printf("Ready to begin? ");	GetLine();}void ReadFileData(graphADT map){	FILE *f;	string filename;	string line;	char meansBuffer[MAX_STRING], toBuffer[MAX_STRING], fromBuffer[MAX_STRING];	graphDataT *mapdata = (graphDataT *) GetGraphData(map);	nodeADT n;	arcADT a;	nodeDataT *nodedata;	arcDataT *arcdata;	printf("Choose a map file (press return for USA Cities): ");	filename = GetLine();	if (!filename[0]) filename = DEFAULT_FILE;	f = fopen(filename, "r");	if (!f) {		printf("File is non-existant.\n"); 		return;	}		mapdata->picture = ReadLine(f);	if (StringEqual(ReadLine(f), "NODES")) {		while (!StringEqual((line = ReadLine(f)), "ARCS")) {			nodedata = GetBlock(sizeof(nodeDataT));			nodedata->name = line;			nodedata->distance = 0;			line = ReadLine(f);			sscanf(line, "%lf %lf\n", &nodedata->location.x, &nodedata->location.y);			n = NewNode(map);			SetNodeData(n, (void *) nodedata);			Enter(mapdata->nodetable, nodedata->name, n);		}		while ((line = ReadLine(f)) != NULL && !StringEqual(line, "")) {			arcdata = GetBlock(sizeof(arcDataT));			sscanf(line, "\"%[^\"]\" from \"%[^\"]\" to \"%[^\"]\" distance: %lf time: %lf cost: %lf risk: %lf\n", 				meansBuffer, fromBuffer, toBuffer, 				&arcdata->distance, &arcdata->time, &arcdata->cost, &arcdata->risk);			arcdata->means = CopyString(meansBuffer);			a = NewArc(Lookup(mapdata->nodetable, fromBuffer), Lookup(mapdata->nodetable, toBuffer));			SetArcData(a, (void *) arcdata);		}	}	fclose(f);}bool BoolQuestion(string prompt){  string answer;  bool result;  printf("%s", prompt);  answer = ConvertToUpperCase(GetLine());  if (StringEqual(answer, "Y")) {    result = TRUE;  } else if (StringEqual(answer, "N")) {    result = FALSE;  } else {    printf("Choose either Y or N.\n");    result = BoolQuestion(prompt);  }  return (result);}void GetUserNodes(graphADT map){	graphDataT *mapdata = (graphDataT *) GetGraphData(map);	nodeDataT *startdata, *finishdata;		printf("Click on start: "); fflush(stdout);	while (!ValidNode(map, GetUserMouseClick(), &mapdata->start)) printf("Try again.\n");	startdata = (nodeDataT *) GetNodeData(*mapdata->start);	printf("%s\n", startdata->name);	DrawOneNode(*mapdata->start, HILITE_COLOR, HILITE_DENSITY);	printf("Click on destination: "); fflush(stdout);	while (!ValidNode(map, GetUserMouseClick(), &mapdata->finish)) printf("Try again.\n");	finishdata = (nodeDataT *) GetNodeData(*mapdata->finish);	printf("%s\n", finishdata->name);	DrawOneNode(*mapdata->finish, HILITE_COLOR, HILITE_DENSITY);}static coord GetUserMouseClick(void){	coord location;		WaitForMouseDown();	WaitForMouseUp();	location.x = GetMouseX();	location.y = GetMouseY();	return location;}bool ValidNode(graphADT map, coord click, nodeADT **nodeptr){	nodeADT node;	nodeDataT *nodedata;	graphDataT *mapdata = (graphDataT *) GetGraphData(map);		foreach (node in Nodes(map)) { 		nodedata = (nodeDataT *) GetNodeData(node);		if (distance(nodedata->location, click) < CIRCLE_RADIUS) {		   *nodeptr = GetBlock(sizeof(nodeADT));		   **nodeptr = node;		   return TRUE;		}		}	return FALSE;}double distance(coord a, coord b){	double dx = a.x - b.x, dy = a.y - b.y;	return sqrt(dx * dx + dy * dy);}void FindRoutes(graphADT map){	graphDataT *mapdata = (graphDataT *) GetGraphData(map);	pathADT best;		printf("*********************************\n");		best = FindShortestPath(*mapdata->start, *mapdata->finish, TimeWeightFn);	printf("The quickest path is %g minutes:\n", TotalPathDistance(best));	MapPath(best, TimeMapFn, NULL);		printf("******Press return for more******\n"); GetLine();	ClearMap(map);	best = FindShortestPath(*mapdata->start, *mapdata->finish, DistanceWeightFn);	printf("The shortest path is %g miles:\n", TotalPathDistance(best));	MapPath(best, DistanceMapFn, NULL);		printf("******Press return for more******\n"); GetLine();	ClearMap(map);	best = FindShortestPath(*mapdata->start, *mapdata->finish, CostWeightFn);	printf("The cheapest path is $ %g:\n", TotalPathDistance(best));	MapPath(best, CostMapFn, NULL);		printf("******Press return for more******\n"); GetLine();	ClearMap(map);	best = FindShortestPath(*mapdata->start, *mapdata->finish, RiskWeightFn);	printf("The path with the least risk has %g risk:\n", TotalPathDistance(best));	MapPath(best, RiskMapFn, NULL);		printf("******Press return for more******\n"); GetLine();	ClearMap(map);	best = FindShortestPath(*mapdata->start, *mapdata->finish, HopsWeightFn);	printf("The path with the fewest hops has %g hop(s):\n", TotalPathDistance(best));	MapPath(best, HopsMapFn, NULL);		printf("*********************************\n");}pathADT FindShortestPath(nodeADT start, nodeADT finish, arcWeightFnT weightFn){	pqueueADT queue;	pathADT path, newPath;	arcADT arc;	queue = NewPriorityQueue();	path = NewPath(weightFn);	while (start != finish) {		if (!IsDistanceFixed(start)) {			FixNodeDistance(start, TotalPathDistance(path));   			foreach (arc in ArcsFrom(start)) {				if (!IsDistanceFixed(EndOfArc(arc))) {					newPath = NewExtendedPath(path, arc);					PriorityEnqueue(queue, newPath,					TotalPathDistance(newPath));				}			}		}		if (IsEmpty(queue)) return (NULL);		path = PriorityDequeue(queue);		start = EndOfPath(path);	}	while (!IsEmpty(queue)) FreePath(PriorityDequeue(queue));	FreeQueue(queue);	return (path);}void FixNodeDistance(nodeADT node, double distance){	nodeDataT *nodedata = (nodeDataT *) GetNodeData(node);		nodedata->distance = distance;	return;}void ClearNodeDistance(nodeADT node){	nodeDataT *nodedata = (nodeDataT *) GetNodeData(node);		nodedata->distance = 0;	return;}bool IsDistanceFixed(nodeADT node){	nodeDataT *nodedata = (nodeDataT *) GetNodeData(node);		return (nodedata->distance != 0);}/* Drawing Functions */void DrawMap(graphADT map){	graphDataT *mapdata = (graphDataT *) GetGraphData(map);		DrawNamedPicture(mapdata->picture);	DrawAllArcs(map);	DrawAllNodes(map);}void ClearMap(graphADT map){	nodeADT node;		foreach (node in Nodes(map)) ClearNodeDistance(node);	MovePen(0, 0);	DrawMap(map);}void DrawPathSegment(arcADT arc, string color, double density){	DrawOneArc(arc, color);	DrawOneNode(StartOfArc(arc), color, density);	DrawOneNode(EndOfArc(arc), color, density);}void DrawAllNodes(graphADT map){	nodeADT node;		foreach (node in Nodes(map)) { DrawOneNode(node, NODE_COLOR, NORMAL_DENSITY); }}void DrawOneNode(nodeADT node, string color, double density){	nodeDataT *nodedata = (nodeDataT *) GetNodeData(node);		MovePen(nodedata->location.x - CIRCLE_RADIUS, nodedata->location.y);	DrawFilledCircle(CIRCLE_RADIUS, color, density);	MovePen(nodedata->location.x + DX, nodedata->location.y + DY);	SetPenColor(TEXT_COLOR);	DrawTextString(nodedata->name);}void DrawFilledCircle(double r, string color, double density){			SetPenColor(color);	StartFilledRegion(density);	DrawArc(r, -180, 360);	EndFilledRegion();	DrawArc(r, -180, 360);}void DrawAllArcs(graphADT map){	arcADT arc;	foreach (arc in Arcs(map)) DrawOneArc(arc, ARC_COLOR);}void DrawOneArc(arcADT arc, string color){	arcDataT *arcdata = (arcDataT *) GetArcData(arc);	nodeDataT *startdata = (nodeDataT *) GetNodeData(StartOfArc(arc));	nodeDataT *enddata = (nodeDataT *) GetNodeData(EndOfArc(arc));	MovePen(startdata->location.x, startdata->location.y);	SetPenColor(color);	DrawLine(enddata->location.x - startdata->location.x, 		enddata->location.y - startdata->location.y);}/* Weight Functions */double TimeWeightFn(arcADT arc){	arcDataT *arcdata = (arcDataT *) GetArcData(arc);		return (arcdata->time);}double DistanceWeightFn(arcADT arc){	arcDataT *arcdata = (arcDataT *) GetArcData(arc);		return (arcdata->distance);}double CostWeightFn(arcADT arc){	arcDataT *arcdata = (arcDataT *) GetArcData(arc);		return (arcdata->cost);}double HopsWeightFn(arcADT arc){	return 1;}double RiskWeightFn(arcADT arc){	arcDataT *arcdata = (arcDataT *) GetArcData(arc);		return (arcdata->risk);}/* Mapping Functions */void TimeMapFn(arcADT arc, void *clientData){	arcDataT *arcdata = (arcDataT *) GetArcData(arc);	nodeDataT *startdata = (nodeDataT *) GetNodeData(StartOfArc(arc));	nodeDataT *enddata = (nodeDataT *) GetNodeData(EndOfArc(arc));		DrawPathSegment(arc, TIME_COLOR, HILITE_DENSITY);	printf("%s from %s to %s: %g mins.\n", arcdata->means, startdata->name, enddata->name, arcdata->time);}void DistanceMapFn(arcADT arc, void *clientData){	arcDataT *arcdata = (arcDataT *) GetArcData(arc);	nodeDataT *startdata = (nodeDataT *) GetNodeData(StartOfArc(arc));	nodeDataT *enddata = (nodeDataT *) GetNodeData(EndOfArc(arc));		DrawPathSegment(arc, DISTANCE_COLOR, HILITE_DENSITY);	printf("%s from %s to %s: %g mi.\n", arcdata->means, startdata->name, enddata->name, arcdata->distance);}void CostMapFn(arcADT arc, void *clientData){	arcDataT *arcdata = (arcDataT *) GetArcData(arc);	nodeDataT *startdata = (nodeDataT *) GetNodeData(StartOfArc(arc));	nodeDataT *enddata = (nodeDataT *) GetNodeData(EndOfArc(arc));		DrawPathSegment(arc, COST_COLOR, HILITE_DENSITY);	printf("%s from %s to %s: $ %g\n", arcdata->means, startdata->name, enddata->name, arcdata->cost);}void HopsMapFn(arcADT arc, void *clientData){	arcDataT *arcdata = (arcDataT *) GetArcData(arc);	nodeDataT *startdata = (nodeDataT *) GetNodeData(StartOfArc(arc));	nodeDataT *enddata = (nodeDataT *) GetNodeData(EndOfArc(arc));		DrawPathSegment(arc, HOPS_COLOR, HILITE_DENSITY);	printf("%s from %s to %s\n", arcdata->means, startdata->name, enddata->name);}void RiskMapFn(arcADT arc, void *clientData){	arcDataT *arcdata = (arcDataT *) GetArcData(arc);	nodeDataT *startdata = (nodeDataT *) GetNodeData(StartOfArc(arc));	nodeDataT *enddata = (nodeDataT *) GetNodeData(EndOfArc(arc));		DrawPathSegment(arc, RISK_COLOR, HILITE_DENSITY);	printf("%s from %s to %s: %g risk\n", arcdata->means, startdata->name, enddata->name, arcdata->risk);}